{"ast":null,"code":"/**\r\n * @license React\r\n * use-sync-external-store-shim.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n\n    var React = require('react');\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    /**\r\n     * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n     */\n\n\n    function is(x, y) {\n      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n      ;\n    }\n\n    var objectIs = typeof Object.is === 'function' ? Object.is : is; // dispatch for CommonJS interop named imports.\n\n    var useState = React.useState,\n        useEffect = React.useEffect,\n        useLayoutEffect = React.useLayoutEffect,\n        useDebugValue = React.useDebugValue;\n    var didWarnOld18Alpha = false;\n    var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n    // because of a very particular set of implementation details and assumptions\n    // -- change any one of them and it will break. The most important assumption\n    // is that updates are always synchronous, because concurrent rendering is\n    // only available in versions of React that also have a built-in\n    // useSyncExternalStore API. And we only use this shim when the built-in API\n    // does not exist.\n    //\n    // Do not assume that the clever hacks used by this hook also work in general.\n    // The point of this shim is to replace the need for hacks by other libraries.\n\n    function useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n    // React do not expose a way to check if we're hydrating. So users of the shim\n    // will need to track that themselves and return the correct value\n    // from `getSnapshot`.\n    getServerSnapshot) {\n      {\n        if (!didWarnOld18Alpha) {\n          if (React.startTransition !== undefined) {\n            didWarnOld18Alpha = true;\n            error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n          }\n        }\n      } // Read the current snapshot from the store on every render. Again, this\n      // breaks the rules of React, and only works here because of specific\n      // implementation details, most importantly that updates are\n      // always synchronous.\n\n      var value = getSnapshot();\n      {\n        if (!didWarnUncachedGetSnapshot) {\n          var cachedValue = getSnapshot();\n\n          if (!objectIs(value, cachedValue)) {\n            error('The result of getSnapshot should be cached to avoid an infinite loop');\n            didWarnUncachedGetSnapshot = true;\n          }\n        }\n      } // Because updates are synchronous, we don't queue them. Instead we force a\n      // re-render whenever the subscribed state changes by updating an some\n      // arbitrary useState hook. Then, during render, we call getSnapshot to read\n      // the current value.\n      //\n      // Because we don't actually use the state returned by the useState hook, we\n      // can save a bit of memory by storing other stuff in that slot.\n      //\n      // To implement the early bailout, we need to track some things on a mutable\n      // object. Usually, we would put that in a useRef hook, but we can stash it in\n      // our useState hook instead.\n      //\n      // To force a re-render, we call forceUpdate({inst}). That works because the\n      // new object always fails an equality check.\n\n      var _useState = useState({\n        inst: {\n          value: value,\n          getSnapshot: getSnapshot\n        }\n      }),\n          inst = _useState[0].inst,\n          forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n      // in the layout phase so we can access it during the tearing check that\n      // happens on subscribe.\n\n\n      useLayoutEffect(function () {\n        inst.value = value;\n        inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({\n            inst: inst\n          });\n        }\n      }, [subscribe, value, getSnapshot]);\n      useEffect(function () {\n        // Check for changes right before subscribing. Subsequent changes will be\n        // detected in the subscription handler.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({\n            inst: inst\n          });\n        }\n\n        var handleStoreChange = function () {\n          // TODO: Because there is no cross-renderer API for batching updates, it's\n          // up to the consumer of this library to wrap their subscription event\n          // with unstable_batchedUpdates. Should we try to detect when this isn't\n          // the case and print a warning in development?\n          // The store changed. Check if the snapshot changed since the last time we\n          // read from the store.\n          if (checkIfSnapshotChanged(inst)) {\n            // Force a re-render.\n            forceUpdate({\n              inst: inst\n            });\n          }\n        }; // Subscribe to the store and return a clean-up function.\n\n\n        return subscribe(handleStoreChange);\n      }, [subscribe]);\n      useDebugValue(value);\n      return value;\n    }\n\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      var prevValue = inst.value;\n\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(prevValue, nextValue);\n      } catch (error) {\n        return true;\n      }\n    }\n\n    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n      // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n      // React do not expose a way to check if we're hydrating. So users of the shim\n      // will need to track that themselves and return the correct value\n      // from `getSnapshot`.\n      return getSnapshot();\n    }\n\n    var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n    var isServerEnvironment = !canUseDOM;\n    var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n    var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n    exports.useSyncExternalStore = useSyncExternalStore$2;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","__REACT_DEVTOOLS_GLOBAL_HOOK__","registerInternalModuleStart","Error","React","require","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","error","format","_len2","arguments","length","args","Array","_key2","printWarning","level","ReactDebugCurrentFrame","stack","getStackAddendum","concat","argsWithFormat","map","item","String","unshift","Function","prototype","apply","call","console","is","x","y","objectIs","Object","useState","useEffect","useLayoutEffect","useDebugValue","didWarnOld18Alpha","didWarnUncachedGetSnapshot","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","startTransition","undefined","value","cachedValue","_useState","inst","forceUpdate","checkIfSnapshotChanged","handleStoreChange","latestGetSnapshot","prevValue","nextValue","useSyncExternalStore$1","canUseDOM","window","document","createElement","isServerEnvironment","shim","useSyncExternalStore$2","exports","registerInternalModuleStop"],"sources":["C:/Users/abronshtein/Desktop/Code/STU/Moodle/client_/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"],"sourcesContent":["/**\r\n * @license React\r\n * use-sync-external-store-shim.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n\r\n          'use strict';\r\n\r\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n}\r\n          var React = require('react');\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\nfunction is(x, y) {\r\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n  ;\r\n}\r\n\r\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\r\n\r\n// dispatch for CommonJS interop named imports.\r\n\r\nvar useState = React.useState,\r\n    useEffect = React.useEffect,\r\n    useLayoutEffect = React.useLayoutEffect,\r\n    useDebugValue = React.useDebugValue;\r\nvar didWarnOld18Alpha = false;\r\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\r\n// because of a very particular set of implementation details and assumptions\r\n// -- change any one of them and it will break. The most important assumption\r\n// is that updates are always synchronous, because concurrent rendering is\r\n// only available in versions of React that also have a built-in\r\n// useSyncExternalStore API. And we only use this shim when the built-in API\r\n// does not exist.\r\n//\r\n// Do not assume that the clever hacks used by this hook also work in general.\r\n// The point of this shim is to replace the need for hacks by other libraries.\r\n\r\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n// React do not expose a way to check if we're hydrating. So users of the shim\r\n// will need to track that themselves and return the correct value\r\n// from `getSnapshot`.\r\ngetServerSnapshot) {\r\n  {\r\n    if (!didWarnOld18Alpha) {\r\n      if (React.startTransition !== undefined) {\r\n        didWarnOld18Alpha = true;\r\n\r\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\r\n      }\r\n    }\r\n  } // Read the current snapshot from the store on every render. Again, this\r\n  // breaks the rules of React, and only works here because of specific\r\n  // implementation details, most importantly that updates are\r\n  // always synchronous.\r\n\r\n\r\n  var value = getSnapshot();\r\n\r\n  {\r\n    if (!didWarnUncachedGetSnapshot) {\r\n      var cachedValue = getSnapshot();\r\n\r\n      if (!objectIs(value, cachedValue)) {\r\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\r\n\r\n        didWarnUncachedGetSnapshot = true;\r\n      }\r\n    }\r\n  } // Because updates are synchronous, we don't queue them. Instead we force a\r\n  // re-render whenever the subscribed state changes by updating an some\r\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\r\n  // the current value.\r\n  //\r\n  // Because we don't actually use the state returned by the useState hook, we\r\n  // can save a bit of memory by storing other stuff in that slot.\r\n  //\r\n  // To implement the early bailout, we need to track some things on a mutable\r\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\r\n  // our useState hook instead.\r\n  //\r\n  // To force a re-render, we call forceUpdate({inst}). That works because the\r\n  // new object always fails an equality check.\r\n\r\n\r\n  var _useState = useState({\r\n    inst: {\r\n      value: value,\r\n      getSnapshot: getSnapshot\r\n    }\r\n  }),\r\n      inst = _useState[0].inst,\r\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\r\n  // in the layout phase so we can access it during the tearing check that\r\n  // happens on subscribe.\r\n\r\n\r\n  useLayoutEffect(function () {\r\n    inst.value = value;\r\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\r\n    // commit phase if there was an interleaved mutation. In concurrent mode\r\n    // this can happen all the time, but even in synchronous mode, an earlier\r\n    // effect may have mutated the store.\r\n\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n  }, [subscribe, value, getSnapshot]);\r\n  useEffect(function () {\r\n    // Check for changes right before subscribing. Subsequent changes will be\r\n    // detected in the subscription handler.\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst: inst\r\n      });\r\n    }\r\n\r\n    var handleStoreChange = function () {\r\n      // TODO: Because there is no cross-renderer API for batching updates, it's\r\n      // up to the consumer of this library to wrap their subscription event\r\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\r\n      // the case and print a warning in development?\r\n      // The store changed. Check if the snapshot changed since the last time we\r\n      // read from the store.\r\n      if (checkIfSnapshotChanged(inst)) {\r\n        // Force a re-render.\r\n        forceUpdate({\r\n          inst: inst\r\n        });\r\n      }\r\n    }; // Subscribe to the store and return a clean-up function.\r\n\r\n\r\n    return subscribe(handleStoreChange);\r\n  }, [subscribe]);\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n\r\nfunction checkIfSnapshotChanged(inst) {\r\n  var latestGetSnapshot = inst.getSnapshot;\r\n  var prevValue = inst.value;\r\n\r\n  try {\r\n    var nextValue = latestGetSnapshot();\r\n    return !objectIs(prevValue, nextValue);\r\n  } catch (error) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\r\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n  // React do not expose a way to check if we're hydrating. So users of the shim\r\n  // will need to track that themselves and return the correct value\r\n  // from `getSnapshot`.\r\n  return getSnapshot();\r\n}\r\n\r\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\r\n\r\nvar isServerEnvironment = !canUseDOM;\r\n\r\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\r\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\r\n\r\nexports.useSyncExternalStore = useSyncExternalStore$2;\r\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\nif (\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\r\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\r\n    'function'\r\n) {\r\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n}\r\n        \r\n  })();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}